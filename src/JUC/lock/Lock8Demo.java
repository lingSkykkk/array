package JUC.lock;


/**
 * 笔记总结
 * 1》 一个对象里面如果有多个synchronize方法，某一个时刻内，只要有一个线程去调用其中的synchronize方法了
 * 其他的线程只能等待， 其中锁的是当前对象this 被锁定后，其他的线程都不能进入到当前其他的其他synchronize方法
 *
 * 2》 加个普通方法后发现和同步锁无关 换成两个对象后，不是通一把锁了 情况立即发生变化
 *
 * 3》 都换成静态同步方法后，情况又发生变换
 * 3种synchronize锁的内容有一些差别：
 * 对于普通同步方法，锁的是当前实例对象，通常指this
 * 对于具体静态同步方法，锁的是当前类的class对象
 * 对于同步方法块，锁的是synchronize括号内的对象
 *
 * 4》 当一个线程试图访问同步代码块时，他首先必须得到锁，正常退出或抛出异常是必须释放锁
 *
 * 所有的普通同步方法用的都是同一把锁--实例对象本身，就是new出来的具体实例对象本身，本类this、
 * 也就是说如果一个实例对象的普通同步方法获取到锁后，该实例对象的其他普通同步方法必须等待获取锁的方法后才能获取锁、
 *
 * 所有的静态同步方法用的也是同一把锁 --类对象本身，就是外面说过的唯一模板 、
 * 具体实例对象this和唯一模板class ，这两把锁是两个不同的对象， 所以静态同步方法与普通同步方法之间不会有竞争条件的
 * 但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁
 *
 */
public class Lock8Demo {
}
